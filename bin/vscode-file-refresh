#!/usr/bin/env bash
#
# vscode-file-refresh — Watch for file changes and notify VS Code in Codespaces
#
# When using terminal-based tools (like Copilot CLI) that modify files on disk,
# VS Code's file explorer and editors may not immediately reflect those changes.
# This script watches for file system events and pokes VS Code to refresh.
#
# Usage:
#   vscode-file-refresh start   Start the watcher daemon in the background
#   vscode-file-refresh stop    Stop the watcher daemon
#   vscode-file-refresh status  Check if the watcher is running
#   vscode-file-refresh watch   Run the watcher in the foreground (for debugging)
#   vscode-file-refresh help    Show this help message
#

set -uo pipefail

PIDFILE="/tmp/vscode-file-refresh.pid"
LOGFILE="/tmp/vscode-file-refresh.log"
WATCH_DIR="${VSCODE_REFRESH_WATCH_DIR:-/workspaces}"
DEBOUNCE_SEC="${VSCODE_REFRESH_DEBOUNCE:-1}"

# Directories to exclude from watching
EXCLUDE_DIRS=(
  "/\\.git/"
  "/vendor/"
  "/tmp/"
  "/node_modules/"
  "/public/assets/"
  "/log/"
  "/\\.bundle/"
  "/\\.cache/"
  "/sorbet/rbi/"
)

usage() {
  sed -n '3,16p' "$0" | sed 's/^# \?//'
}

# Find the active VS Code remote CLI binary
find_vscode_cli() {
  local commit_hash

  # Get the commit hash from the running VS Code server process
  commit_hash=$(ps aux 2>/dev/null \
    | grep '[c]ode-server\|server-main\.js' \
    | grep -oP '(?<=/bin/linux-x64/)[a-f0-9]+' \
    | head -1)

  if [[ -n "$commit_hash" ]]; then
    # Check both Codespaces (/vscode) and SSH Remote (~/.vscode-remote) paths
    for base in /vscode/bin/linux-x64 /home/vscode/.vscode-remote/bin; do
      local cli="${base}/${commit_hash}/bin/remote-cli/code"
      if [[ -x "$cli" ]]; then
        echo "$cli"
        return 0
      fi
    done
  fi

  # Fallback: find any available remote CLI
  local cli
  cli=$(find /vscode/bin /home/vscode/.vscode-remote/bin -path '*/bin/remote-cli/code' -type f 2>/dev/null | head -1)
  if [[ -n "$cli" && -x "$cli" ]]; then
    echo "$cli"
    return 0
  fi

  return 1
}

# Find the most recent VS Code IPC socket
find_vscode_ipc() {
  ls -t /tmp/vscode-ipc-*.sock 2>/dev/null | head -1
}

# Notify VS Code about a changed file by opening it briefly
notify_vscode() {
  local file="$1"
  local cli="$2"
  local ipc="$3"

  # Only notify for files that exist (skip deletes — VS Code handles those via parent dir)
  if [[ -f "$file" ]]; then
    VSCODE_IPC_HOOK_CLI="$ipc" "$cli" "$file" >/dev/null 2>&1 || true
  fi
}

# Main watch loop
run_watch() {
  if ! command -v inotifywait &>/dev/null; then
    echo "Error: inotifywait not found. Install inotify-tools." >&2
    exit 1
  fi

  local vscode_cli
  vscode_cli=$(find_vscode_cli) || {
    echo "Error: VS Code server not found. Is VS Code connected?" >&2
    exit 1
  }

  local vscode_ipc
  vscode_ipc=$(find_vscode_ipc) || {
    echo "Error: VS Code IPC socket not found." >&2
    exit 1
  }

  echo "Watching ${WATCH_DIR} for file changes..."
  echo "VS Code CLI: ${vscode_cli}"
  echo "VS Code IPC: ${vscode_ipc}"

  # Build exclude regex
  local exclude_pattern
  exclude_pattern=$(printf "|%s" "${EXCLUDE_DIRS[@]}")
  exclude_pattern="(${exclude_pattern:1})"

  # Track last notification time for debouncing (temp file approach for subshell compat)
  local debounce_dir
  debounce_dir=$(mktemp -d /tmp/vscode-refresh-debounce.XXXXXX)
  trap "rm -rf '$debounce_dir'" EXIT

  while read -r changed_file; do
    # Skip directories
    [[ -d "$changed_file" ]] && continue

    # Debounce using temp files with modification time
    local hash
    hash=$(echo "$changed_file" | md5sum | cut -d' ' -f1)
    local stamp_file="${debounce_dir}/${hash}"
    if [[ -f "$stamp_file" ]]; then
      local stamp_age=$(( $(date +%s) - $(stat -c %Y "$stamp_file") ))
      if (( stamp_age < DEBOUNCE_SEC )); then
        continue
      fi
    fi
    touch "$stamp_file"

    # Re-discover IPC socket (it can change if VS Code reconnects)
    local current_ipc
    current_ipc=$(find_vscode_ipc) || continue

    notify_vscode "$changed_file" "$vscode_cli" "$current_ipc" &
  done < <(inotifywait \
    --monitor \
    --recursive \
    --event create \
    --event modify \
    --event delete \
    --event move \
    --exclude "$exclude_pattern" \
    --format '%w%f' \
    "$WATCH_DIR")
}

do_start() {
  if [[ -f "$PIDFILE" ]]; then
    local old_pid
    old_pid=$(cat "$PIDFILE")
    if kill -0 "$old_pid" 2>/dev/null; then
      echo "Already running (PID ${old_pid})"
      return 0
    fi
    rm -f "$PIDFILE"
  fi

  echo "Starting vscode-file-refresh daemon..."
  nohup "$0" watch >> "$LOGFILE" 2>&1 &
  local pid=$!
  echo "$pid" > "$PIDFILE"
  disown "$pid" 2>/dev/null || true
  echo "Started (PID ${pid}). Log: ${LOGFILE}"
}

do_stop() {
  if [[ ! -f "$PIDFILE" ]]; then
    echo "Not running (no PID file)"
    return 0
  fi

  local pid
  pid=$(cat "$PIDFILE")
  if kill -0 "$pid" 2>/dev/null; then
    # Kill the process group to also stop inotifywait
    kill -- -"$(ps -o pgid= -p "$pid" | tr -d ' ')" 2>/dev/null || kill "$pid" 2>/dev/null || true
    echo "Stopped (PID ${pid})"
  else
    echo "Process ${pid} not found (stale PID file)"
  fi
  rm -f "$PIDFILE"
}

do_status() {
  if [[ ! -f "$PIDFILE" ]]; then
    echo "Not running"
    return 1
  fi

  local pid
  pid=$(cat "$PIDFILE")
  if kill -0 "$pid" 2>/dev/null; then
    echo "Running (PID ${pid})"
    return 0
  else
    echo "Not running (stale PID file)"
    rm -f "$PIDFILE"
    return 1
  fi
}

case "${1:-help}" in
  start)  do_start ;;
  stop)   do_stop ;;
  status) do_status ;;
  watch)  run_watch ;;
  help|--help|-h)
    usage
    ;;
  *)
    echo "Unknown command: $1" >&2
    usage >&2
    exit 1
    ;;
esac
